import { AuthManagerError, AuthManagerErrorDict } from '@/services/auth-manager/auth/vault-errors';
import { GetKeycloakClient } from '@/services/auth-manager/auth/keycloak-client';
import { GetStorage } from '@/services/auth-manager/auth/token-vault-factory';
import { decryptToken } from '@/services/auth-manager/auth/encryption';

export interface RefreshTokenIdParams {
  userId: string;
  sessionId?: string;
}

export interface RefreshTokenIdResult {
  persistentTokenId: string;
}

/**
 * Refreshes the refresh token ID for a given persistent ID.
 *
 * This function interacts with the storage layer to fetch the user's existing
 * refresh token, decrypts it, and uses the Keycloak client to refresh the access token.
 * If successful, the new refresh token is stored and its ID is returned.
 *
 * @param params - The parameters required to fetch and refresh the token.
 * @param params.userId - The unique identifier of the user whose refresh token is being retrieved.
 *
 * @returns A promise that resolves to an object containing the persistent token ID.
 *
 * @throws {AuthManagerError} If no refresh token is found for the user.
 * @throws {AuthManagerError} If the refresh token is invalid or cannot be decrypted.
 * @throws {AuthManagerError} If no new refresh token is generated by the Keycloak client.
 */
export async function makeNewRefreshTokenId(
  params: RefreshTokenIdParams
): Promise<RefreshTokenIdResult> {
  const { userId, sessionId } = params;

  const storage = GetStorage();
  const client = GetKeycloakClient();
  const entry = await storage.getUserRefreshTokenByUserId({ userId });

  if (!entry)
    throw new AuthManagerError(AuthManagerErrorDict.invalid_request.code, {
      reason: 'No session nor was found',
    });

  if (!entry.encryptedToken || !entry.iv) {
    throw new AuthManagerError(AuthManagerErrorDict.token_not_found.code, {
      reason: 'No active refresh token was found',
    });
  }

  const decryptedToken = decryptToken(entry.encryptedToken, entry.iv);
  const refreshToken = await client.refreshAccessToken(decryptedToken);

  if (!refreshToken || !refreshToken.refresh_token) {
    throw new AuthManagerError(AuthManagerErrorDict.no_refresh_token.code, {
      reason: 'No refresh token was generated',
    });
  }

  const newRefreshTokenId = await storage.upsertRefreshToken({
    userId: entry.userId,
    token: refreshToken.refresh_token,
    sessionStateId: refreshToken.session_state,
    metadata: {
      sessionId,
    },
  });

  return {
    persistentTokenId: newRefreshTokenId,
  };
}
